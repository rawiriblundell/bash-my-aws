#!/bin/bash

hosted-zones() {

  # List Route53 Hosted Zones
  #
  #     $ hosted-zones
  #     /hostedzone/Z3333333333333  5   NotPrivateZone  bash-my-aws.org.
  #     /hostedzone/Z5555555555555  2   NotPrivateZone  bash-my-universe.com.
  #     /hostedzone/Z4444444444444  3   NotPrivateZone  bashmyaws.org.
  #     /hostedzone/Z1111111111111  3   NotPrivateZone  bash-my-aws.com.
  #     /hostedzone/Z2222222222222  3   NotPrivateZone  bashmyaws.com.

  local ids=$(skim-stdin)
  local filters=$(__bma_read_filters $@)

  aws route53 list-hosted-zones \
    --output text \
    --query "
      HostedZones[${ids:+?contains(['${ids// /"','"}'], Id)}].[
        Id,
        ResourceRecordSetCount,
        (Config.PrivateZone && 'PrivateZone') || 'NotPrivateZone',
        Name
      ]" |
    sort -k 4 |
    grep -E -- "$filters" |
    columnise
}

hosted-zone-ns-records() {

  # Generate NS records for delegating domain to AWS
  #
  #     $ hosted-zones bash-my-aws.org
  #     /hostedzone/ZJ6ZCG2UD6OKX  5  NotPrivateZone  bash-my-aws.org.
  #
  #     $ hosted-zones bash-my-aws.org | hosted-zone-ns-records
  #     bash-my-aws.org. 300 IN NS	ns-786.awsdns-34.net.
  #     bash-my-aws.org. 300 IN NS	ns-1549.awsdns-01.co.uk.
  #     bash-my-aws.org. 300 IN NS	ns-362.awsdns-45.com.
  #     bash-my-aws.org. 300 IN NS	ns-1464.awsdns-55.org.

  local inputs=$(skim-stdin "$@")
  local hosted_zone_id=$(echo "$inputs" | awk '{print $1}')
  [[ -z "$hosted_zone_id" ]] && __bma_usage "hosted-zone-id" && return 1

  local hosted_zone_name
  hosted_zone_name=$(
    aws route53 list-resource-record-sets \
      --hosted-zone-id "$hosted_zone_id" \
      --query "ResourceRecordSets[?Type=='NS'].Name" \
      --output text
  )

  aws route53 list-resource-record-sets \
    --hosted-zone-id "$hosted_zone_id" \
    --output text \
    --query "
      ResourceRecordSets[?Type=='NS'].ResourceRecords[].[
        '$hosted_zone_name 300 IN NS',
        Value
      ]"
}

hosted-zone-delete() {
  # Delete Route53 hosted zones
  #
  # USAGE: hosted-zone-delete hosted-zone-id [hosted-zone-id]
  #
  # EXAMPLE:
  #     $ hosted-zone-delete /hostedzone/Z1111111111111
  #     Deleting hosted zone /hostedzone/Z1111111111111
  #
  local zone_ids=$(skim-stdin "$@")
  [[ -z "$zone_ids" ]] && __bma_usage "hosted-zone-id [hosted-zone-id]" && return 1

  local zone_id
  for zone_id in $zone_ids; do
    echo "Deleting hosted zone $zone_id"
    aws route53 delete-hosted-zone \
      --id "$zone_id"
  done
}

r53-zones(){

  # List Route53 Hosted Zones
  #
  #     $ r53-zones
  #     /hostedzone/Z3333333333333  5   NotPrivateZone  bash-my-aws.org.
  #     /hostedzone/Z5555555555555  2   NotPrivateZone  bash-my-universe.com.
  #     /hostedzone/Z4444444444444  3   NotPrivateZone  bashmyaws.org.
  #     /hostedzone/Z1111111111111  3   NotPrivateZone  bash-my-aws.com.
  #     /hostedzone/Z2222222222222  3   NotPrivateZone  bashmyaws.com.

  # SUPPORTED OPTION FLAGS:

  #     '-P|--private'
  #     '-p|--public'
  #
  #     RATIONALE:
  #     Sometimes you can find the undesirable situation of the same domain name
  #     being used for both public and private zones.  This enables differentiation
  #
  #     '-x|--exact'
  #
  #     RATIONALE
  #     The default behaviour matches a given domain and its subdomains e.g:
  #       'r53-zones contoso.com' would match contoso.com, prod.contoso.com, internal.contoso.com etc
  #       'r53-zones --exact contoso.com' matches only contoso.com

  local ids filters query_filter filter_parts exact_match zone_name joined
  filter_parts=()
  exact_match=""
  zone_name=""

  while (( $# > 0 )); do
    case "$1" in
      (-P|--private) filter_parts+=("Config.PrivateZone == \`true\`"); shift 1 ;;
      (-p|--public)  filter_parts+=("Config.PrivateZone == \`false\`"); shift 1 ;;
      (-x|--exact)   exact_match=true; shift 1 ;;
      (*)            break ;;
    esac
  done

  ids=$(skim-stdin)

  if [[ -n "${exact_match}" && -n "${1}" ]]; then
    zone_name="${1}"
    [[ "${zone_name}" != *. ]] && zone_name="${zone_name}."
    filter_parts+=("Name == '${zone_name}'")
    shift 1
  fi

  filters=$(__bma_read_filters "$@")

  [[ -n "${ids}" ]] && filter_parts+=("contains(['${ids// /"','"}'], Id)")

  if (( ${#filter_parts[@]} > 0 )); then
    joined=$(printf -- '%s && ' "${filter_parts[@]}")
    query_filter="?${joined% && }"
  fi

  aws route53 list-hosted-zones \
    --output text               \
    --query "
      HostedZones[${query_filter}].[
        Id,
        ResourceRecordSetCount,
        (Config.PrivateZone && 'PrivateZone') || 'NotPrivateZone',
        Name
      ]"                  |
    sort -k 4             |
    grep -E -- "${filters}" |
    columnise
}

r53-zone-records(){

  # List Records in a Route53 Hosted Zone
  # NOTE: AWS alias records are shown with a fake TTL of 86400.
  #
  #     $ r53-zones bash-my-aws.org
  #     /hostedzone/ZJ6ZCG2UD6OKX  5  NotPrivateZone  bash-my-aws.org.
  #
  #     $ r53-zones bash-my-aws.org | r53-zone-records
  #     bash-my-aws.org.  900 SOA ns-1549.awsdns-01.co.uk. awsdns-hostmaster.amazon.com. 1 7200 900 1209600 86400
  #     bash-my-aws.org.  300 NS  ns-1464.awsdns-55.org.
  #     bash-my-aws.org.  300 A 185.199.108.153
  #     bash-my-aws.org.  300 A 185.199.109.153
  #     bash-my-aws.org.  300 TXT "google-site-verification=RbKejqu95y4Q78BkWnjaiM0rl6SYugtTdVLexK35b2k"
  #     lb.bash-my-aws.org. 86400 ALIAS dualstack.lb-bmaorg-12345.us-east-1.elb.amazonaws.com

  # SUPPORTED OPTIONS:

  # --type [Required: type]
  #     RATIONALE:
  #     This allows robust filtering by record type
  #
  #     EXAMPLE:
  #     $ r53-zones bash-my-aws.org | r53-zone-records --type A
  #     bash-my-aws.org.  300 A 185.199.108.153
  #     bash-my-aws.org.  300 A 185.199.109.153

  local record_type hosted_zone_id jq_script

  case "${1}" in
    (--type)
      record_type="${2}"
      shift 2
    ;;
  esac

  hosted_zone_id="$(skim-stdin "${@}")"
  [[ -z "${hosted_zone_id}" ]] && __bma_usage "r53-zone-records" && return 1

  read -r -d '' jq_script <<'EOF'
    .ResourceRecordSets[] |
    select(.Type == $record_type or $record_type == "") |
    if .AliasTarget then
      "\(.Name)\t86400\tALIAS\t\(.AliasTarget.DNSName)\n"
    else
      "\(.Name)\t\(.TTL)\t\(.Type)\t\(.ResourceRecords[].Value)\n"
    end
EOF

  aws route53 list-resource-record-sets --hosted-zone-id "${hosted_zone_id}" --output json |
    jq -jr --arg record_type "${record_type}" "${jq_script}" |
    columnise
}

